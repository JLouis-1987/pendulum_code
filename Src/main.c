/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>

#include "stm32f4xx.h"
#include "clock.h"
#include "timer.h"
#include "led.h"
#include "uart.h"
#include "utils/ringbuffer.h"
#include "commands.h"
#include "i2c.h"
#include "lsm6dso.h"
#include "encoder.h"

/*TODOs
 * -Create structure and read function to read accerometer data and convert to real units.
 * -tie execution to an interrupt based timer (start with 100 Hz) or a timed super loop
 * -Create cli interface to dump data to the the serial port.
 *
 * -set up code to drive the motor controller
 * 	- check to see if there is a library for this
 *
 * - set up PID loop to control motor speed
 * 	- need to figure out loop time for this and set up a interrupt
 *
 *
 *
 */


/* Pin outs
 * I2C to ADC
 * 	PB8 --> SCL
 * 	PB7 --> SDA
 * Debug UART
 * 	PA2 --> TX
 * 	PA3 --> RX
 * Encoder Input TIM3
 * 	PB4 --> Ch1
 * 	PB5 --> Ch2
 * Motor Control TIM 9
 *  PE5 --> CH1
 *  PE6 --> CH2
  */


int main(void)
{
	/*initialize the MCU peripherals*/
	clock_init();
	init_leds();
	init_PC6();
	I2C1_Init();
	tim8_output_compare();
	uart2_rxtx_interrupt_init();
	init_encoder();
	printf("MCU peripheral inits complete \n\r");

	/*initialize the other devices on the board*/
	if(check_IMU() == true){
		printf("IMU responded with correct device ID\n\r");
	}
	init_lsm6dso();


	printf("Hello World\n\r");

	while(1)
	{
		if(rx_buffer_count() > 0){
			process_commands();
		}

	}

}

void USART2_IRQHandler(void)
{
	if(USART2->SR & SR_RXNE){
		uart_rx_callback();
	}
	if(USART2->SR & SR_TXE){
		uart_tx_callback();
	}

}

void TIM3_IRQHandler(void) {
    if (TIM3->SR & TIM_SR_CC1IF) { // Check capture flag
        uint16_t captured_value = TIM3->CCR1; // Read captured value
        uint16_t direction_value = (GPIOB->IDR & 0x20); //read other pin for direction
        encoder_callback(captured_value, direction_value);
        TIM3->SR &= ~TIM_SR_CC1IF; // Clear flag

    }
}


